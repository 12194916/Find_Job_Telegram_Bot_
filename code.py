# -*- coding: utf-8 -*-
"""Telegram_bot.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nPq-R8we4ABahHbvijwTScU47VDehPU-
"""

pip install pyTelegramBotAPI

import pandas as pd
job_data = {
    "Software Developer": ["Python", "Java", "C++", "JavaScript", "SQL"],
    "Data Analyst": ["Excel", "Python", "SQL", "Tableau", "Power BI"],
    "Web Developer": ["HTML", "CSS", "JavaScript", "PHP", "MySQL"],
    "Product Manager": ["Product development", "Agile", "Leadership", "Strategy", "sociable"],
}

df=pd.DataFrame(job_data)
df

job_offers = [
    "We're seeking a talented berlin python remote hybrid onsite c++ front-end developer hybrid with experience in React, Angular, and c++, pyhton, paris Vue to join our team. The ideal candidate will also have a strong knowledge of HTML, CSS, and JavaScript.\nLocation: Seattle",
    "We're looking for a UX designer python hybrid with experience in paris designing user html, interfaces and creating wireframes remote  and prototypes. The ideal candidate will also have experience with tools like Sketch and Figma.\nLocation: Chicago, IL",
    "We're seeking a digital paris python hybrid marketing manager with experience in SEO, SEM, email marketing, and social media advertising. The ideal candidate will also have experience with tools like Google Analytics and HubSpot.\nLocation: Remote",
    "We're looking for a full-stack developer with experience in React, Node.js, and MongoDB remote to join our team. The ideal candidate will also have experience with AWS.\nLocation: Los Angeles, CA",
    "We're seeking a data scientist with experience in Python, R, and berlin machine learning to analyze and interpret remote hybrid complex data sets. The ideal candidate will also have experience with SQL and data visualization tools like Tableau.\nLocation: Boston, MA",
    "We're looking for a technical writer with experience in python creating documentation for software products. The ideal candidate will also have experience with tools like Confluence and Jira.\nLocation: New York, NY",
    "We're seeking a UI designer with experience in creating intuitive user interfaces and mobile app design. The ideal candidate will also have experience with tools like Adobe XD and InVision.\nLocation: San Francisco, CA",
    "We're looking for a project manager with python experience in leading python, cross-functional hybrid teams and managing project timelines. remote The ideal candidate will also have experience with Agile methodologies.\nLocation: Remote",
    "We're seeking a python remote DevOps engineer with experience in AWS, Docker, and Kubernetes to join our team. The ideal candidate paris will remote also have experience with CI/CD pipelines and Git.\nLocation: Austin, TX",
    "We're looking for a sales representative with experience in B2B sales and account management. html The ideal candidate will also have experience with CRM tools like Salesforce.\nLocation: Denver, CO",
    "We're seeking a content writer with hybrid  experience in creating engaging remote blog posts and articles. The ideal paris candidate will also have experience with SEO and keyword research.\nLocation: Remote",
    "We're looking for a graphic designer with experience in creating visual designs sql for marketing campaigns and social media. The ideal candidate will also have experience with tools like Photoshop and Illustrator.\nLocation: Miami, FL",
    "We're seeking an IT support specialist with experience in troubleshooting hardware and software onsite issues. The ideal candidate will also have experience with Active Directory and Office 365.\nLocation: Hybrid (San Diego, CA)",
    "We're looking for an HR manager with sql, experience in managing employee relations, benefits, and recruitment. The ideal candidate will also have experience with HRIS tools like BambooHR.\nLocation: Dallas, TX",
    "We're seeking a cybersecurity analyst with experience in network berlin security, python vulnerability assessments, remote and incident response. The ideal candidate will also have experience with tools like Nessus and Splunk.\nLocation: Remote"
]


df_1=pd.DataFrame(job_offers,columns=['offers'])
df_1

pip install flashtext

import pandas as pd
from flashtext import KeywordProcessor

def find_matching_offers(selected_skills, selected_modes, selected_cities=None, df=None):
    # create a KeywordProcessor instance for skills and modes
    kp_skills = KeywordProcessor()
    for skill in selected_skills:
        kp_skills.add_keyword(skill.lower())

    kp_modes = KeywordProcessor()
    for mode in selected_modes:
        kp_modes.add_keyword(mode.lower())

    # create a KeywordProcessor instance for cities only when selected_cities is provided
    if selected_cities is not None:
        kp_cities = KeywordProcessor()
        for city in selected_cities:
            kp_cities.add_keyword(city.lower())

    # create an empty list to store offers that match the skills, modes, and cities
    final_matched_offers = []

    # loop through each offer in the dataframe
    for offer in df['offers']:
        offer_lower = offer.lower()

        # use the keyword processor to search and match skills, modes, and cities (if provided)
        matches_skills = kp_skills.extract_keywords(offer_lower)
        matches_modes = kp_modes.extract_keywords(offer_lower)
        if selected_cities is not None:
            matches_cities = kp_cities.extract_keywords(offer_lower)
        else:
            matches_cities = [1]  # set to non-empty value to pass the check

        # check if at least one of each selected skill, mode, and city is found
        if (len(matches_skills) > 0 and
            len(matches_modes) > 0 and
            len(matches_cities) > 0):
                # add offer to the final_matched_offers list
                final_matched_offers.append(offer)

    return final_matched_offers

import telebot
from telebot import types
import re

# Use your own bot token here
bot_token = '5883561149:AAHoZJNRf25YaK-aKZr9qqpkrMJdRu9Uxk0'
bot = telebot.TeleBot(bot_token)

# Replace mock values with the DataFrame and the country-city mapping

country_city_mapping = {
    'france': ['paris', 'lyon', 'marseille'],
    'germany': ['berlin', 'munich', 'frankfurt'],
    'south korea': ['seoul', 'busan', 'incheon'],
    'china': ['beijing', 'shanghai', 'shenzhen'],
    'USA': ['new york', 'los angeles', 'san francisco'],
}


# Globals to store user's selections
selected_titles = set()
selected_skills = set()
selected_modes = set()
selected_locations = set()
selected_cities = set()


@bot.message_handler(commands=['start'])
def send_welcome(message):
    selected_titles.clear()
    selected_skills.clear()
    selected_modes.clear()
    selected_locations.clear()
    selected_cities.clear()
    bot.reply_to(message, "Welcome! Let's start selecting job titles.")
    send_job_titles(message.chat.id)

def split_list(input_list, chunk_size):
    return [input_list[i:i + chunk_size] for i in range(0, len(input_list), chunk_size)]


def send_job_titles(chat_id):
    markup = types.InlineKeyboardMarkup(row_width=3)

    title_buttons = [types.InlineKeyboardButton(title, callback_data=f"title_{i+1}") for i, title in enumerate(df.columns)]
    for button_group in split_list(title_buttons, 3):
        markup.row(*button_group)

    btn_done = types.InlineKeyboardButton("✅ Done", callback_data="titles_done")
    markup.row(btn_done)
    bot.send_message(chat_id, "Please select one or more job titles:", reply_markup=markup)

def send_skills(chat_id):
    # Get all the skills for the selected titles
    all_skills = set()
    for title in selected_titles:
        skills = df[title].tolist()
        all_skills.update(skills)

    markup = types.InlineKeyboardMarkup(row_width=3)

    # Check if the skill is in the user-selected skills while creating the skill_buttons list
    skill_buttons = [
        types.InlineKeyboardButton(skill, callback_data=f"skill_{skill}")
        for skill in all_skills
        if skill not in selected_skills
    ]
    for button_group in split_list(skill_buttons, 3):
        markup.row(*button_group)

    btn_done = types.InlineKeyboardButton("✅ Done", callback_data="skills_done")
    markup.row(btn_done)
    bot.send_message(chat_id, "Please select one or more skills:", reply_markup=markup)

def send_modes(chat_id):
    markup = types.InlineKeyboardMarkup(row_width=3)

    modes = ['remote', 'hybrid', 'onsite']
    mode_buttons = [types.InlineKeyboardButton(mode, callback_data=f"mode_{i+1}") for i, mode in enumerate(modes)]
    for button_group in split_list(mode_buttons, 3):
        markup.row(*button_group)

    btn_done = types.InlineKeyboardButton("✅ Done", callback_data="modes_done")
    markup.row(btn_done)
    bot.send_message(chat_id, "Please select one or more modes of the job:", reply_markup=markup)


def locations_strategy(mode):
    return mode == 'hybrid' or mode == 'onsite'


def send_locations(chat_id):
    markup = types.InlineKeyboardMarkup(row_width=3)

    location_buttons = [types.InlineKeyboardButton(loc, callback_data=f"loc_{i+1}") for i, loc in enumerate(country_city_mapping.keys())]
    for button_group in split_list(location_buttons, 3):
        markup.row(*button_group)

    btn_done = types.InlineKeyboardButton("✅ Done", callback_data="locations_done")
    markup.row(btn_done)
    bot.send_message(chat_id, "Please select one or more locations for the job:", reply_markup=markup)

def send_cities(chat_id):
    markup = types.InlineKeyboardMarkup(row_width=3)

    for loc in selected_locations:
        if loc in country_city_mapping:  # Add this condition to check whether the location is in the dictionary
            city_buttons = []
            for i, city in enumerate(country_city_mapping[loc]):
                btn = types.InlineKeyboardButton(city, callback_data=f"{loc}_city_{i+1}")
                city_buttons.append(btn)
        
            for button_group in split_list(city_buttons, 3):
                markup.row(*button_group)

    btn_done = types.InlineKeyboardButton("✅ Done", callback_data="cities_done")
    markup.row(btn_done)
    bot.send_message(chat_id, "Please select one or more cities for the chosen locations:", reply_markup=markup)



def show_result(chat_id):
    if len(selected_locations) > 0:
        final_offers = find_matching_offers(selected_skills, selected_modes, selected_locations, df_1)
    else:
        final_offers = find_matching_offers(selected_skills, selected_modes, None, df_1)
    message = (
            f"Selected job titles: {selected_titles}\n"
            f"Selected skills: {selected_skills}\n"


                    
            f"Selected modes of the job: {selected_modes}\n"
            f"Selected locations of the job: {selected_locations}\n"
            f"Selected cities of the job: {selected_cities}\n\n"
            f"Matching job offers:"
        )
    bot.send_message(chat_id, message)
    if len(final_offers) > 0:
      for offer in final_offers:
            bot.send_message(chat_id, offer)
    else:
        message = "No matching jobs found."
        bot.send_message(chat_id, message)

@bot.callback_query_handler(func=lambda call: True)
def callback_handler(call):
    data = call.data
    chat_id = call.message.chat.id

    if data.startswith("title_"):
        i = int(data.split("_")[1]) - 1
        title = df.columns[i]

        if title not in selected_titles:
            selected_titles.add(title)
        else:
            selected_titles.remove(title)

    elif data == "titles_done":
        send_skills(chat_id)

    elif data.startswith("skill_"):
      skill = data[len("skill_"):]  # This line remains the same
    
      if skill not in selected_skills:
        selected_skills.add(skill)
      else:
        selected_skills.remove(skill)

    elif data == "skills_done":
        send_modes(chat_id)

    elif data.startswith("mode_"):
      i = int(data.split("_")[1])
      mode_text = ['remote', 'hybrid', 'onsite'][i - 1]

      if mode_text not in selected_modes:
          selected_modes.add(mode_text)
      else:
          selected_modes.remove(mode_text)

    elif data == "modes_done":
      # Check if 'remote' is the only selected mode
      if len(selected_modes) == 1 and 'remote' in selected_modes:
          show_result(chat_id)
      else:
          send_locations(chat_id)

    elif data.startswith("loc_"):
        i = int(data.split("_")[1]) - 1
        loc = list(country_city_mapping.keys())[i]

        if loc not in selected_locations:
            selected_locations.add(loc)
        else:
            selected_locations.remove(loc)

    elif data == "locations_done":
      send_cities(chat_id)

    elif "_city_" in data:
      loc, _, i_str = data.split("_")
      i = int(i_str) - 1
      city = country_city_mapping[loc][i]

      if city not in selected_cities:
          selected_cities.add(city)
      else:
        selected_cities.remove(city)

    elif data == "cities_done":
        show_result(chat_id)

if __name__ == '__main__':
    bot.polling()